//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can be verified
//! on-chain.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package fibonacci-script --bin prove --release
//! ```

use std::time::Instant;

use k256::{
    ecdsa::{
        signature::{SignatureEncoding, Signer, Verifier}, DerSignature, RecoveryId, Signature, SigningKey, VerifyingKey
    }, EncodedPoint, PublicKey
};
use rand::rngs::OsRng;
use serde::{Serialize, Deserialize};
use sp1_sdk::{ProverClient, SP1Stdin};
use tiny_keccak::{Hasher, Keccak};
use sha3::{Digest, Keccak256};

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const FIBONACCI_ELF: &[u8] = include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SigVerify {
    pub message: Vec<u8>,
    pub pubkey: PublicKey,
    pub signature: Signature,
    pub recovery_id: u8,    
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SigVerifyWithHash {
    pub pubkey: PublicKey,
    pub signature: Signature,
    pub recovery_id: u8,
    pub prehash: [u8; 32],
}

fn keccak_bench() {
        // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(FIBONACCI_ELF);


    let _message = b"Hello, world! This is a test message.Hello, world! This is a test message.".to_vec();
    let _hash_chain_num = 1 as usize;

    let mut hasher = Keccak::v256();
    hasher.update(&_message);
    let mut output = [0u8; 32];
    hasher.finalize(&mut output);

    // Setup the inputs.;
    let mut stdin = SP1Stdin::new();
    stdin.write(&(_message, _hash_chain_num));

    let now = Instant::now();

    let proof = client.prove(&pk, stdin).expect("failed to generate proof");

    let prover_time = now.elapsed();

    // Deserialize the public values.
    let bytes = proof.public_values.as_slice();
    // assert_eq!(bytes, &output[..]);
    print!(
        "Public values: {:?} prover time {:?}",
        bytes,
        prover_time.as_secs()
    );

    client
        .verify(&proof, &vk)
        .expect("verification failed");
}


fn ecdsa_withhash_bench() {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(FIBONACCI_ELF);

   

    let sig_data = || -> SigVerifyWithHash {
        let _signing_key = SigningKey::random(&mut OsRng);
        let _verifying_key = VerifyingKey::from(&_signing_key);
    
    
        let _message = b"Hello, world! This is a test message.";
        let prehash = Keccak256::new_with_prefix(_message);
        let (_signature, _recoverid) = _signing_key.sign_digest_recoverable(prehash.clone()).unwrap();
    
        let recid = _recoverid;
        let prehash_bytes: [u8; 32] = prehash.finalize().into();
        
        let recovered_key = VerifyingKey::recover_from_prehash(&prehash_bytes, &_signature, recid).unwrap();
        let _pub_key = PublicKey::from(&recovered_key);

        SigVerifyWithHash {
            pubkey: _pub_key,
            prehash: prehash_bytes,
            signature: _signature,
            recovery_id: recid.to_byte(),
        }
    };

    // Setup the inputs.;
    let mut stdin = SP1Stdin::new();
    let sig_verify = (0..20).map(|_| sig_data()).collect::<Vec<_>>();
    stdin.write(&sig_verify);

    let now = Instant::now();

    let proof = client.prove(&pk, stdin).expect("failed to generate proof");

    let prover_time = now.elapsed();

    // Deserialize the public values.
    let bytes = proof.public_values.as_slice();
    println!(
        "prover time {:?}",
        prover_time.as_secs()
    );
}

fn ecdsa_bench() {
     // Setup the logger.
     sp1_sdk::utils::setup_logger();

     // Setup the prover client.
     let client = ProverClient::new();
 
     // Setup the program.
     let (pk, vk) = client.setup(FIBONACCI_ELF);
 
     let _signing_key = SigningKey::random(&mut OsRng);
     let _verifying_key = VerifyingKey::from(&_signing_key);

 
     let _message = b"Hello, world! This is a test message.";
     let prehash = Keccak256::new_with_prefix(_message);
     let (_signature, _recoverid) = _signing_key.sign_digest_recoverable(prehash.clone()).unwrap();

     let recid = _recoverid;
     let prehash_bytes: [u8; 32] = prehash.finalize().into();
     
     let recovered_key = VerifyingKey::recover_from_prehash(&prehash_bytes, &_signature, recid).unwrap();
     let _pub_key = PublicKey::from(&recovered_key);
 
     // Setup the inputs.;
     let mut stdin = SP1Stdin::new();
     let sig_verify = SigVerify {
         message: _message.to_vec(),
         pubkey: _pub_key,
         signature: _signature,
         recovery_id: recid.to_byte(),
     };
     stdin.write(&sig_verify);
 
     let now = Instant::now();
 
     let proof = client.prove(&pk, stdin).expect("failed to generate proof");
 
     let prover_time = now.elapsed();
 
     // Deserialize the public values.
     let bytes = proof.public_values.as_slice();
     println!(
         "prover time {:?}",
         prover_time.as_secs()
     );
}

fn main() {
    // keccak_bench()
    ecdsa_withhash_bench()
    // ecdsa_bench()
}
